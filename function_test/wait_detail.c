
의존성
#include <sys/wait.h>
```pid_t wait(int *status);

wait 함수는 자식 프로세스의 종료를 부모 프로세스에서 기다린다는 개념으로
간단히 이해할 수 있다. 이전 fork 함수의 예제를 보면 자식 프로세스는 0.1초동안
sleep상태가 되어 부모프로세스가 먼저 종료되었는데, 이때 자식 프로세스의 ppid는 1
이 되면서 고아 프로세스가 된다. 이와 같은 현상을 방지할 때 사용되는 것이 wait 
wait함수를 사용하게 되면 부모 프로세스는 자식 프로세스가 종료될 때까지 sleep 상태로 기다리게 되며,
자식 프로세스가 종료되었을 때 비로소 wait함수 이후의 구문을 부모 프로세스가 처리 할 수 있게 된다.
그렇다면 자식 프로세스를 기다리지 않아도 되는 상황에서는 wait함수를 쓰지 않아도
되는 것일까? 이에 대한 답을 아래의 예시에서 찾아보자

자식 프로세스가 main문의 return 혹은 exit을 통해 명시된 종료 코드에 의해서 어찌됐든
종료가 되면 wait 함수의 반환값은 자식프로세스의 pid가 되고 드렇지 않고 자식 프로세스가 시그널에 의해 종료됨녀
errno가 EINTR로 설정되면서 -1을 반환한다. wait함수의 인자로 받은 status는 자식 프로세스가 종료되면서
반환한 다양한 정보들을 기록하게 된다. 자식프로세스와 부모 프로세스의 메모리 공간이 별도로 유지되기 때문에 status라는 인자는 
자식 프로세스에게 넘어가서 기록되는 것이 아니라 말 그대로 자식 프로세스가 종료되면서 넘긴 정보들을 부모 프로세스가 취하면서 자식프로세스의 종료 시점에 기록되는 것이다.
wait함수에서 사용되는 status는 waitpid에서 사용되는 status와 동일

wait함수를 호출하는 주된 목적은 자식 프로세스의 종료를 기다리는 것 말고도, 부모 프로세스에서 생성된
자식 프로세스를 수거하는데 있다. 주어진 코드를 실행해보면 부모 프로세스가 무한 루프에 걸려 있기 때문에
자식 프로세스가 풀력 구문을 수행한 뒤에 부모프로세스보다 먼저 동료되는 것!
자식 프로세스가 정상적으로 부모 프로세스 보다 먼저 종료되었기 때문에 아무 문제가 없을 것 같지만, 주어진 결과를
살펴보면 자식 프로세스가 여전히 살아서 좀비 프로세스로 유지가 되고 있다. 좀비 프로세스는 이름처럼 부모프로세스가
종료되기 전까지는 프로세스 테이블에 남아 있는 상태로 유지가 된다. 따라서 부모 프로세스는 꼭 wait함수를 호출하면서 자식 프로세스를 
수거 하여 프로세스 테이블에서 삭제할 의무가 있으므로 이에 따따 wait함수를 호출 하자

#include <stdio.h>
#include <unistd.h>

int	main(void)
{
	pid_t	pid;
    pid_t	ret;

	pid = fork();
	if (pid == -1)
		return (1);
	else if (!pid)
		printf("Child: I will be exited\n");
	else
	{
		printf("Parent: I have a Child which pid is %d\n", pid);
        ret = wait(NULL);
        while (1)
			;
	}
	return (0);

}

의존성 : #include <sys/wait.h>

``` pid_t waitpid(pid_t pid, int *status, int options);

함수설명
waitpid 함수에서는 wait함수와 달리 pid_t 타입으로된 pid와 int 타입의 option을 추가적으로
인자로 사용하는 것을 볼 수 있다. waitpid의 기능 자체는 wait함수와동일하게, 정상적으로
자식 프로세스의 상태를 획득하고 자원을 수거하고 반환하는데 있다. 그렇다면 어떤 기능이 다른지 추가적으로 받은 인자들을
알아보고, waitpid함수가 만들어진 의의!

wait함수에서 보았던 이전 예시들을 보면 부모 프로세스에서 생성된 자식 프로세스는 단 1개
만약 부모프로세스에서 fork를 통해 생성한 자식프로세스가 1개가 아니라 여러개라면 wait 함수를
이용했을 때 부모 프로세스 의 context는 임의의 자식 프로세스의 종료를 기다렸다가 수거하게 된다. 즉,
특정 pid를 가진 자식 프로세스에 대한 wait이 불가능 하다는 것! 따라서 특정 프로세스에 대해서 수행할 수
있도록 waitpid함수에는 pid라는 인자를 받게 되어 있다. 이 때 waitpid의 pid로 -1이라는 값을 주게 되면
wait과 같은 동작하여 임의의 프로세스를 수거



